<!doctype html><html lang="en"><head><meta charset="utf-8"><title>Shadow DOM — WebComponents.org</title><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"><meta name="google-site-verification" content="px-LvGmZP4t9mI3QVcWkTYciiRbToixpY-F-NfIybaE"><meta name="author" content="Community"><meta name="description" content="A place to discuss and evolve Web Component best-practices"><meta name="theme-color" content="#3a99d7"><meta property="og:title" content="Shadow DOM — WebComponents.org"><meta property="og:image" content="https://webcomponents.github.io/img/logo.png"><meta property="og:url" content="https://webcomponents.github.io/polyfills/shadow-dom"><meta property="og:description" content="A place to discuss and evolve Web Component best-practices"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Shadow DOM — WebComponents.org"><meta name="twitter:description" content="A place to discuss and evolve Web Component best-practices"><meta name="twitter:image" content="https://webcomponents.github.io/img/logo.png"><meta name="twitter:site" content="@Web_Components"><link rel="stylesheet" href="https://webcomponents.github.io/css/main.min.css"><link rel="stylesheet" href="https://webcomponents.github.io/css/syntax-highlight.min.css"><!--[if lt IE 10]>
    <link rel="stylesheet" media="all" href="https://webcomponents.github.io/css/ielt10.min.css">
    <![endif]--><link rel="icon" type="image/x-icon" href="https://webcomponents.github.io/img/favicon.ico"><link rel="publisher" href="https://plus.google.com/+WebcomponentsOrg"><script src="//use.typekit.net/ksn6mlw.js"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="page-wrap"><header class="header-bar" role="banner"><div class="wrapper"><a class="logo" href="https://webcomponents.github.io"><img src="https://webcomponents.github.io/img/logo.svg" alt="WebComponents.org" width="60" height="39"> </a><a class="menu-button"><span></span> <span></span> <span></span></a><nav class="nav desktop-only" role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement"><ul><li class="nav-item"><a href="https://webcomponents.github.io/" class="nav-link" title="Home" itemprop="url"><span itemprop="name">Home</span></a></li><li class="nav-item nav-active"><a href="https://webcomponents.github.io/polyfills/" class="nav-link" title="Polyfills" itemprop="url"><span itemprop="name">Polyfills</span></a></li><li class="nav-item"><a href="https://webcomponents.github.io/articles/" class="nav-link" title="Articles" itemprop="url"><span itemprop="name">Articles</span></a></li><li class="nav-item"><a href="https://webcomponents.github.io/presentations/" class="nav-link" title="Presentations" itemprop="url"><span itemprop="name">Presentations</span></a></li><li class="nav-item"><a href="https://webcomponents.github.io/podcasts/" class="nav-link" title="Podcasts" itemprop="url"><span itemprop="name">Podcasts</span></a></li><li class="nav-item"><a href="https://webcomponents.github.io/resources/" class="nav-link" title="Resources" itemprop="url"><span itemprop="name">Resources</span></a></li></ul></nav><script>(function() {
            var cx = '006706517617519397807:s_k6dwkdtby';
            var gcse = document.createElement('script');
            gcse.type = 'text/javascript';
            gcse.async = true;
            gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                '//www.google.com/cse/cse.js?cx=' + cx;
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(gcse, s);
        })();</script><div class="search-box desktop-only"><gcse:search></gcse:search></div></div></header><div class="notification_toolbar"><p class="notification_toolbar__header">Please help us make Web Components & PWA's better by completing <a target="_blank" href="https://bit.ly/web-survey-2016">this survey</a></p></div><div id="resources" class="wrapper"><main class="layout-single" role="main"><div class="single-content" role="article"><section class="card card-story" role="region"><p class="title" itemprop="name">Shadow DOM</p><div class="post-info" role="complementary"><p class="post-edit"><span class="icon-pencil"></span> <a href="https://github.com/webcomponents/webcomponents.github.io/edit/site/src/documents/polyfills/shadow-dom.html.md">Edit this page</a></p></div><div class="description" itemprop="text"><h2 id="learn-the-tech">Learn the tech</h2><h3 id="why-shadow-dom-">Why Shadow DOM?</h3><p><a href="http://w3c.github.io/webcomponents/spec/shadow/">Shadow DOM</a> addresses the lack of true DOM tree encapsulation when building components. With Shadow DOM, elements can get a new kind of node associated with them. This new kind of node is called a shadow root. An element that has a shadow root associated with it is called a shadow host.</p><p>The content of a shadow host isn’t rendered; the content of the shadow root is rendered instead.</p><h3 id="shadow-dom-subtrees">Shadow DOM subtrees</h3><p>Shadow DOM allows a single node to express three subtrees: <em>light DOM</em>, <em>shadow DOM</em>, and <em>composed DOM</em>.</p><p>Together, the light DOM and shadow DOM are referred to as the <em>logical DOM</em>. This is the DOM that the developer interacts with. The composed DOM is what the browser sees and uses to render the pixels on the screen.</p><p><strong>Light DOM</strong></p><p>The user of your custom element supplies the light DOM:</p><pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">my-custom-element</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">q</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-title">q</span>&gt;</span> <span class="hljs-comment">&lt;!-- part of my-custom-element's light DOM --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">my-custom-element</span>&gt;</span>
</code></pre><p>The light DOM of <code>&lt;my-custom-element&gt;</code> is visible to the end-user of the element as a normal subtree. They can access <code>.childNodes</code>, <code>.children</code>, <code>.innerHTML</code>, or any other property or method that gives information about a node&#39;s subtree.</p><p><strong>Shadow DOM</strong></p><p><code>&lt;my-custom-element&gt;</code> may define shadow DOM by attaching a shadow root to itself.</p><pre class="highlight"><code class="hljs xml">#shadow-root
  <span class="hljs-comment">&lt;!-- everything in here is my-custom-element's shadow DOM --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>People say: <span class="hljs-tag">&lt;<span class="hljs-title">content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">footer</span>&gt;</span>sometimes<span class="hljs-tag">&lt;/<span class="hljs-title">footer</span>&gt;</span>
</code></pre><p>Shadow DOM is internal to the element and hidden from the end-user. Its nodes are not children of <code>&lt;my-custom-element&gt;</code>.</p><h3 id="basic-usage">Basic usage</h3><pre class="highlight"><code class="hljs coffeescript"><span class="hljs-reserved">var</span> el = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
<span class="hljs-reserved">var</span> shadow = el.createShadowRoot();
shadow.innerHTML = <span class="hljs-string">'&lt;content select="q"&gt;&lt;/content&gt;'</span>;
<span class="hljs-built_in">document</span>.body.appendChild(el);
</code></pre><p><strong>Composed (rendered) DOM</strong></p><p>The composed DOM is what the browser actually renders. For rendering, the light DOM is distributed into the shadow DOM to produce the composed DOM. The final output looks something like this:</p><pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">my-custom-element</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>People say: <span class="hljs-tag">&lt;<span class="hljs-title">q</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-title">q</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">footer</span>&gt;</span>sometimes<span class="hljs-tag">&lt;/<span class="hljs-title">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">my-custom-element</span>&gt;</span>
</code></pre><p>Nodes in light DOM or shadow DOM express parent and sibling relationships that match their respective tree structures; the relationships that exist in the composed tree are not expressed anywhere in DOM. So, while the <code>&lt;span&gt;</code> in the final composed tree is a child of <code>&lt;my-custom-element&gt;</code> and the parent of <code>&lt;q&gt;</code>, it is actually a child of the shadow root and <code>&lt;q&gt;</code> is a child of <code>&lt;my-custom-element&gt;</code>. The two nodes are unrelated but Shadow DOM renders them as if they are. In this way, the user can manipulate light DOM or shadow DOM directly as regular DOM subtrees, and let the system take care of keeping the render tree synchronized.</p><h2 id="polyfill-details">Polyfill details</h2><p>A polyfill to provide Shadow DOM functionality in browsers that don&#39;t support it natively.</p><p>First download the <code>webcomponents.js</code> <a href="https://github.com/WebComponents/webcomponentsjs">polyfills</a> using <a href="http://bower.io">Bower</a>:</p><pre class="highlight"><code class="hljs sql">bower <span class="hljs-operator"><span class="hljs-keyword">install</span> <span class="hljs-comment">--save webcomponentsjs</span>
</span></code></pre><p>Include the <code>ShadowDOM.js</code> or <code>ShadowDOM.min.js</code> (minified) file in your project.</p><pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"bower_components/webcomponentsjs/ShadowDOM.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre><p>Alternatively, you can directly use <code>webcomponents.js</code> (or the minified <code>webcomponents.min.js</code> file) in your project.</p><h2 id="polyfill-notes">Polyfill notes</h2><p>This section explains how a proper (native) implementation differs from our polyfill implementation.</p><h3 id="wrappers">Wrappers</h3><p>The polyfill is implemented using <em>wrappers</em>. A wrapper wraps the native DOM node in a wrapper node. The wrapper node looks and behaves identically to the native node (minus bugs and known limitations). For example:</p><pre class="highlight"><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">div</span> = document.createElement(<span class="hljs-string">'div'</span>);
<span class="hljs-keyword">div</span>.innerHTML = <span class="hljs-string">'&lt;b&gt;Hello world&lt;/b&gt;'</span>;
assert(<span class="hljs-keyword">div</span>.firstChild instanceof HTMLElement);
</code></pre><p>But <code>div</code> is actually a wrapper of the element that the browser normally gives you. This wrapper just happens to have the same interface as the browser provided element.</p><p>It has an <code>innerHTML</code> setter that works just like the native <code>innerHTML</code> but instead of working on the composed tree it works on the local DOM. When you change the logical DOM tree like this it might cause the composed tree to need to be re-rendered. This does not happen immediately, but it is scheduled to happen later as needed.</p><p>The wrapper node also has a <code>firstChild</code> getter which once again works on the logical DOM.</p><p><code>instanceof</code> still works because we have replaced the global <code>HTMLElement</code> constructor with our custom one.</p><h4 id="more-logical-dom">More Logical DOM</h4><p>The <code>wrappers.Node</code> object keeps track of the logical (light as well as shadow, but not composed) DOM. Internally it has has the 5 fundamental Node pointers, <code>parentNode</code>, <code>firstChild</code>, <code>lastChild</code>, <code>nextSibling</code> and <code>previousSibling</code>. When the DOM tree is manipulated these pointers are updated to always represent the logical tree. When the shadow DOM renderer needs to render the visual tree, these internal pointers are updated as needed.</p><h4 id="wrap-all-the-objects-">Wrap all the objects!</h4><p>The intent is to wrap all the DOM objects that interact with the DOM tree. For this polyfill to be completely transparent we need to wrap a lot of APIs. Any method, accessor or constructor that takes or returns a Node or an object that indirectly touches a node needs to be wrapped. As you can imagine there are a lot of these. At the moment we have done the most common ones but there are sure to be missing ones as soon as you try to use this with your code.</p><h3 id="-wrap-and-unwrap-"><code>wrap</code> and <code>unwrap</code></h3><p>There are bound to be cases where we haven&#39;t done the wrapping for you. In those cases you can use <code>wrap</code> to create a wrapper of a native object, or <code>unwrap</code> to get the underlying native object from a wrapper. These two functions are available on the <code>ShadowDOMPolyfill</code> object.</p><p>ex:</p><pre class="highlight"><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">wrap</span><span class="hljs-params">(document.body)</span></span>
<span class="hljs-comment">// or get body of the wrapped document</span>
<span class="hljs-function"><span class="hljs-title">wrap</span><span class="hljs-params">(document)</span></span><span class="hljs-class">.body</span>

<span class="hljs-function"><span class="hljs-title">unwrap</span><span class="hljs-params">(div)</span></span><span class="hljs-class">.firstChild</span> instanceof HTMLElement
</code></pre><p>If you plan to work with elements that need to be wrapped over and over, try passing a wrapped version of the element into an immediately-invoked function expression.</p><pre class="highlight"><code class="hljs clojure"><span class="hljs-list">(<span class="hljs-keyword">function</span><span class="hljs-list">(<span class="hljs-keyword">document</span>)</span> <span class="hljs-collection">{

  // Now a library like jQuery can add
  // listeners to the wrapped document
  $<span class="hljs-list">(<span class="hljs-keyword">document</span>)</span>.on<span class="hljs-list">(<span class="hljs-keyword">'click'</span>, function<span class="hljs-list">(<span class="hljs-keyword">e</span>)</span> <span class="hljs-collection">{
    console.log<span class="hljs-list">(<span class="hljs-keyword">'Clicked</span> on', e.target)</span><span class="hljs-comment">;</span>
  }</span>)</span><span class="hljs-comment">;</span>

}</span>)</span><span class="hljs-list">(<span class="hljs-keyword">wrap</span><span class="hljs-list">(<span class="hljs-keyword">document</span>)</span>)</span><span class="hljs-comment">;</span>
</code></pre><h4 id="event-retargetting">Event Retargetting</h4><p>An important aspect of the shadow DOM is that events are retargetted to never expose the shadow DOM to the light DOM. For example.</p><pre class="highlight"><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">div</span> = document.createElement(<span class="hljs-string">'div'</span>);
<span class="hljs-keyword">div</span>.innerHTML = <span class="hljs-string">'Click me'</span>;
<span class="hljs-keyword">var</span> shadow = <span class="hljs-keyword">div</span>.createShadowRoot();
shadow.innerHTML = <span class="hljs-string">'&lt;b&gt;&lt;content&gt;&lt;/content&gt;&lt;/b&gt;'</span>;
</code></pre><p>If the user clicks on the <code>div</code> the real <code>target</code> of the click event is the <code>&lt;b&gt;</code> element. But that element is not visible in the light DOM so the target is therefore retargetted to the <code>div</code> element itself. However, if there is an event listener on the <code>&lt;content&gt;</code>, <code>&lt;b&gt;</code> or the shadow root, the target should be visible to the event listener.</p><p>Similar issues occur with <code>relatedTarget</code> in <code>mouseover</code> and <code>mouseout</code> events.</p><p>To support this kind of behavior the event dispatching in the browser has to be reimplemented by the polyfill.</p><h4 id="known-limitations">Known limitations</h4><ul><li>CSS encapsulation is limited.</li><li><code>Object.prototype.toString</code> does not return the same string as for native objects.</li><li>No live <code>NodeList</code>s. All node lists are snapshotted upon read.</li><li><code>document</code>, <code>window</code>, <code>document.body</code>, <code>document.head</code> and others are non configurable and cannot be overridden. We are trying to make these work as seamlessly as possible but there will doubtlessly be cases where there will be problems; for those cases you can use <code>wrap</code> and <code>unwrap</code> to get unblocked.</li><li>Cross window/frame access is not implemented.</li><li>CSS <code>:host()</code> rules can only have (at most) 1-level of nested parentheses in its argument selector. For example, <code>:host(.zot)</code> and <code>:host(.zot:not(.bar))</code> both work, but <code>:host(.zot:not(.bar:nth-child(2)))</code> does not.</li></ul><h2 id="tools-testing">Tools &amp; Testing</h2><p>For running tests or building minified files, consult the <a href="https://github.com/WebComponents/webcomponentsjs#manually-building">Manual Builds</a> guide.</p></div></section></div><div class="single-sidebar"><section class="card card-tags"><h3>Polyfills</h3><ul class="tag-list"><li><a href="/polyfills/"><span class="icon-arrow-right"></span> Introduction</a></li><li><a href="/polyfills/custom-elements/"><span class="icon-arrow-right"></span> Custom Elements</a></li><li><a href="/polyfills/html-imports/"><span class="icon-arrow-right"></span> HTML Imports</a></li><li><a href="/polyfills/shadow-dom/"><span class="icon-arrow-right"></span> Shadow DOM</a></li></ul></section></div></main></div></div><div class="aux-nav"><nav class="wrapper" role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement"><ul><li>Learn</li><li><a href="https://webcomponents.github.io/articles/" title="Articles" itemprop="url"><span itemprop="name">Articles</span></a></li><li><a href="https://webcomponents.github.io/presentations/" title="Presentations" itemprop="url"><span itemprop="name">Presentations</span></a></li><li><a href="https://webcomponents.github.io/podcasts/" title="Podcasts" itemprop="url"><span itemprop="name">Podcasts</span></a></li></ul><ul><li>Code</li><li><a href="https://webcomponents.github.io/polyfills/" title="Polyfills" itemprop="url"><span itemprop="name">Polyfills</span></a></li><li><a href="https://webcomponents.github.io/resources/" title="Resources" itemprop="url"><span itemprop="name">Resources</span></a></li></ul><ul><li>Community</li><li><a href="https://webcomponents.github.io/about/" title="About" itemprop="url"><span itemprop="name">About</span></a></li><li><a href="https://webcomponents.github.io/assets/" title="Assets" itemprop="url"><span itemprop="name">Assets</span></a></li><li><a href="https://webcomponents.github.io/swags/" title="Swags" itemprop="url"><span itemprop="name">Swags</span></a></li></ul></nav></div><footer class="credits" role="contentinfo"><div class="wrapper"><p>Made with <span class="love">♥</span> by the <a target="_blank" class="credits-link" href="https://github.com/webcomponents/webcomponents.github.io/graphs/contributors" itemprop="publisher">WebComponents.org contributors.</a></p><ul class="social-buttons"><li class="tweet-btn"><iframe src="http://platform.twitter.com/widgets/tweet_button.1359159993.html#_=1360010161235&amp;count=horizontal&amp;id=twitter-widget-0&amp;lang=en&amp;size=m&amp;url=https://webcomponents.github.io&amp;text=WebComponents.org ~ A place to discuss and evolve Web Component best-practices" class="twitter-share-button twitter-count-horizontal" data-twttr-rendered="true" allowtransparency="true" frameborder="0" scrolling="no" width="100" height="20"></iframe></li><li class="fb-btn"><iframe src="//www.facebook.com/plugins/like.php?href=https://webcomponents.github.io&amp;send=false&amp;layout=button_count&amp;width=100&amp;show_faces=false&amp;font&amp;colorscheme=light&amp;action=like&amp;height=20&amp;appId=176947299114210" allowtransparency="true" frameborder="0" scrolling="no" width="85" height="20"></iframe></li><li class="gplus-btn"><iframe src="https://plusone.google.com/_/+1/fastbutton?bsv&amp;size=medium&amp;hl=en-US&amp;url=https://webcomponents.github.io&amp;parent=https://webcomponents.github.io" allowtransparency="true" frameborder="0" scrolling="no" width="70" height="20"></iframe></li><li class="github-btn"><iframe src="http://ghbtns.com/github-btn.html?user=webcomponents&amp;repo=webcomponents.github.io&amp;type=watch&amp;count=true&amp;size=small" allowtransparency="true" frameborder="0" scrolling="0" width="85" height="20"></iframe></li></ul></div></footer><script src="https://webcomponents.github.io/js/main.js"></script><script>window.__insp = window.__insp || [];
__insp.push(['wid', 1646634871]);
(function() {
    function __ldinsp(){var insp = document.createElement('script'); insp.type = 'text/javascript'; insp.async = true; insp.id = "inspsync"; insp.src = ('https:' == document.location.protocol ? 'https' : 'http') + '://cdn.inspectlet.com/inspectlet.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(insp, x); }
    if (window.attachEvent){
        window.attachEvent('onload', __ldinsp);
    }else{
        window.addEventListener('load', __ldinsp, false);
    }
})();</script><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-47408119-2']);
_gaq.push(['_trackPageview']);

(function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>